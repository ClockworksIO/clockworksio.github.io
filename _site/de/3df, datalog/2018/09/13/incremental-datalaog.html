<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    
    <meta name="description" content="Präzise Antworten auf komplexe Fragestellungen. In Echtzeit." />
    <meta property="og:title" content="Clockworks UG" />
    <meta property="og:description" content="Präzise Antworten auf komplexe Fragestellungen. In Echtzeit." />

    <link rel="icon" type="image/png" href="/assets/favicon.png" />
    <link rel="stylesheet" type="text/css" href="/css/main.css" />
    <link rel="stylesheet" type="text/css" href="/css/github-theme.css">

    <title>Incremental Datalog with Differential Dataflows</title>
</head>

  <body>
    <header>
  <div id="nav-container">
    <h1><a href="/#">clockworks</a></h1>
    <div class="menu-separator"></div>
    <section id="page-header">
      <nav id="primary-navigation">
        <ul>
          
          <li><a href="/de#what" data-scroll>Was?</a></li>
          <li><a href="/de#customers" data-scroll>Wo?</a></li>
          <li><a href="/de#team" data-scroll>Wer?</a></li>
          <li><a href="/de/blog" data-scroll>Ideen</a></li>
          
        </ul>
      </nav>
    </section>
    <div class="menu-separator"></div>
  </div>
</header>


    <main>
      <article>
        <h1>Incremental Datalog with Differential Dataflows</h1>
        <div id="post-info">
          <div class="face" style="background-image: url('/assets/team/niko.jpg')"></div>
          <span>by Nikolas Göbel</span>
        </div>
        
        <!--abstract-->

<p><strong>Abstract</strong><br />
<em>We propose a method of continuously executing Datalog queries over
data streams, by compiling them to <a href="https://github.com/frankmcsherry/differential-dataflow">differential
dataflows</a>. This
work originated at <a href="https://www.systems.ethz.ch/">ETH Zurich’s Systems
group</a>, in collaboration with <a href="http://www.frankmcsherry.org/">Frank
McSherry</a> and <a href="https://www.inf.ethz.ch/personal/alonso/alonso_page.html">Prof. Gustavo
Alonso</a>.</em></p>

<p><em>This post is the first in an ongoing series on differential Datalog.</em></p>

<p>Most databases today provide a very straightforward access model: A
client sends a query, which is promptly answered using whatever
internal datastructures the DBMS is maintaining. In the context of
scalable real-time data pipelines and stream processing architectures
this access model becomes problematic. In order to retrieve live
updates of query results, clients have to poll the database at regular
intervals, thus placing significant load on the server.</p>

<p>Pub/sub architectures on top of durable logs do not have this problem,
but can only propagate novelty at the granularity of a ‘topic’. Every
consumer is responsible for joining, filtering, and aggregating new
tuples into the query results they actually are interested
in. Consequently, consumers must be able to keep up with the overall
throughput on a topic, even though they might only ever work with a
very small subset of messages.</p>

<p>Ideally we would want a system which allows clients to declare
interest in information via the same powerful query languages we’re
used to from relational databases, but is then able to update query
results as new tuples enter the sytem — without computing full result
sets from scratch.</p>

<p>Our work tackles a number of use cases.</p>

<p><strong>Analysis of large, dynamic graphs.</strong> Graph processing is here to
stay, as more and more organizations of all sizes and across varying
industries rely on it.[6] Datalog with its recursive rules is well
suited to express graph queries and executing those over larger and
larger graphs as thousands of edges change every second seems like a
worthwile challenge.</p>

<blockquote>
  <p>We note that the 22 software products in Table 1 have limited or no
support for incremental and streaming computations.</p>
  <ul>
    <li>Sahu et al. 2018, <a href="https://github.com/frankmcsherry/differential-dataflow">The Ubiquity of Large Graphs</a> [6]</li>
  </ul>
</blockquote>

<p><strong>Scalable view maintenance.</strong> We want to be able to maintain highly
specific, potentially inter-dependent views for many thousand
concurrent users over high-frequency event streams, subject to complex
access policies. Of course we want users to be able to register and
unregister queries at their leisure, just like they would with a SQL
database.</p>

<p><strong>Live, interactive web applications.</strong> Scalable view maintenance and
near real-time propagation of changes allows us to efficiently treat
web clients as just another database peer. This idea is laid out in
<a href="http://tonsky.me/blog/the-web-after-tomorrow/">“The Web After
Tomorrow”</a>[7], much
more lucid than we can hope to achieve here. The following quotes and
illustration are taken directly from Nikita’s post.</p>

<p><img src="/assets/web-after-tomorrow.jpg" alt="" /></p>

<blockquote>
  <p>Web pages are usually pretty complex, they may track hundreds of
different objects, they may track results of complex queries, they
may track aggregations. And we might have thousands of live clients
connected at the same time.</p>
</blockquote>

<blockquote>
  <p>What we need here is probably a new query language, something like
reversible SQL. We need our hypothetical ReversibleQL to run
efficiently in both directions.</p>
</blockquote>

<h3 id="related-work">Related work</h3>

<p>Naturally, various systems already exist in this interesting
space. The Apache Kafka project introduced a streaming SQL engine not
too long ago[4] and ‘changefeeds’ have been one of RethinkDB’s[5] most
distinctive features for a while now. We wanted to provide such an
incrementalized execution engine for the Datalog language and explore
how well the powerful primitives offered by Differential dataflow
would be suited to such an undertaking. This post is meant to provide
a high-level overview of what we’re up too, in-depth discussions,
comparisons, and examples will follow.</p>

<h3 id="differential-dataflow">Differential dataflow</h3>

<p>From its <a href="https://github.com/frankmcsherry/differential-dataflow">GitHub repository</a>:</p>

<blockquote>
  <p>Differential dataflow is a data-parallel programming framework
designed to efficiently process large volumes of data and to quickly
respond to arbitrary changes in input collections.</p>
</blockquote>

<p>Differential dataflow[0][1] (<em>Differential</em>) allows us to express
incremental computations (i.e. computations that will only do work on
the order of changes to the dataset) using the familiar language of
<code class="highlighter-rouge">map</code>, <code class="highlighter-rouge">filter</code>, <code class="highlighter-rouge">join</code>, <code class="highlighter-rouge">group</code>, and friends. Crucially, Differential
also allows us to have loops within our dataflow graph. These will
cause a sub-computation to execute repeatedly until a fixpoint is
reached, i.e. until the result set does not change anymore.</p>

<p>As Differential’s author Frank McSherry
<a href="https://github.com/frankmcsherry/blog/blob/master/posts/2016-06-21.md">notes</a>,
Datalog programs map very nicely onto these primitives.</p>

<h3 id="declarative-differential-dataflows-3df">Declarative Differential Dataflows (3DF)</h3>

<p>The 3DF project is an experimental implementation of an incremental
Datalog engine based on Differential dataflow. It is meant to be used
on top of systems like Datomic or Kafka, providing durability and any
other features you’d expect from a proper database. 3DF consists of a
<a href="https://github.com/comnik/declarative-dataflow">library and
server</a>[2] written in
Rust, providing dynamic synthetization of rather explicit query plans
(like those found in SQL engines) into differential dataflows.</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="c1">;; a simple query plan
</span><span class="w">
</span><span class="p">{</span><span class="no">:Project</span><span class="w"> 
  </span><span class="p">[{</span><span class="no">:Join</span><span class="w"> </span><span class="p">[{</span><span class="no">:HasAttr</span><span class="w"> </span><span class="p">[</span><span class="n">?e</span><span class="w"> </span><span class="no">:name</span><span class="w"> </span><span class="n">?name</span><span class="p">]}</span><span class="w">
           </span><span class="p">{</span><span class="no">:HasAttr</span><span class="w"> </span><span class="p">[</span><span class="n">?e</span><span class="w"> </span><span class="no">:age</span><span class="w"> </span><span class="n">?age</span><span class="p">]}</span><span class="w"> </span><span class="n">?e</span><span class="p">]}</span><span class="w"> 
   </span><span class="p">[</span><span class="n">?e</span><span class="w"> </span><span class="n">?name</span><span class="w"> </span><span class="n">?age</span><span class="p">]]}</span><span class="w">
</span></code></pre>
</div>

<p>On top of this we provide <a href="https://github.com/comnik/clj-3df">a
frontend</a>[3] in Clojure(Script)
which compiles Datalog expressions into query plans and offers a
WebSocket interface for registering queries and receiving results. We
did not want to invent a new flavour of Datalog (yet?) and thus
implemented <a href="https://docs.datomic.com/on-prem/query.html">Datomic’s query
language</a> — which itself
is modeled closely after Datalog.</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="c1">;; a simple query for parents of the child with id 100
</span><span class="w">
</span><span class="p">[</span><span class="no">:find</span><span class="w"> </span><span class="n">?parent</span><span class="w"> </span><span class="no">:where</span><span class="w"> </span><span class="p">[</span><span class="n">?parent</span><span class="w"> </span><span class="no">:parent/child</span><span class="w"> </span><span class="mi">100</span><span class="p">]]</span><span class="w">
</span></code></pre>
</div>

<p>Because 3DF is designed with long-running, continuously updated
queries in mind, we are less concerned with the one-time cost of
parsing, interpreting, and optimizing a query. By splitting the system
this way we gain the freedom to experiment with different data models
on the backend, and with query syntax on the frontend.</p>

<p>We’ll take a deep dive into 3DF internals in a future post.</p>

<h3 id="sources">Sources</h3>

<ul>
  <li>[0] <a href="https://github.com/frankmcsherry/differential-dataflow">github.com/frankmcsherry/differential-dataflow</a></li>
  <li>[1] <a href="https://github.com/frankmcsherry/differential-dataflow/blob/master/differentialdataflow.pdf">McSherry et al., “Differential dataflow”</a></li>
  <li>[2] <a href="https://github.com/comnik/declarative-dataflow">github.com/comnik/declarative-dataflow</a></li>
  <li>[3] <a href="https://github.com/comnik/clj-3df">github.com/comnik/clj-3df</a></li>
  <li>[4] <a href="https://github.com/confluentinc/ksql">Kafka Streaming SQL</a></li>
  <li>[5] <a href="https://www.rethinkdb.com/blog/realtime-web/">RethinkDB</a></li>
  <li>[6] <a href="https://github.com/frankmcsherry/differential-dataflow">The Ubiquity of Large Graphs</a></li>
  <li>[7] <a href="http://tonsky.me/blog/the-web-after-tomorrow/">The Web After Tomorrow</a></li>
</ul>

      </article>
    </main>

    <footer>
    <div class="footer-content">
        <section>
            Clockworks UG (haftungsbeschränkt)<br/>
            Simsonstraße 5<br/>
            60385 Frankfurt am Main<br/>
        </section>
        <section>
            <a href="mailto:contact@clockworks.io">contact@clockworks.io</a><br/>
            <a href="/impressum">Impressum</a><br />
            &#169; Clockworks 2018
        </section>
    </div>
</footer>


    <script type="text/javascript" src="/js/scroll.js"></script>
<script type="text/javascript">

const header = document.getElementById('nav-container');

smoothScroll.init({offset: header.offsetHeight});

function onPageScroll () {
  if (window.pageYOffset > header.offsetTop) {
    header.classList.add('sticky');
  } else {
    header.classList.remove('sticky');
  }
}

window.onscroll = onPageScroll;

</script>

    
    <script>
  (function(d) {
    var config = {
      kitId: 'gxp4jrv',
      scriptTimeout: 3000,
      async: true
    },
    h=d.documentElement,t=setTimeout(function(){h.className=h.className.replace(/\bwf-loading\b/g,"")+" wf-inactive";},config.scriptTimeout),tk=d.createElement("script"),f=false,s=d.getElementsByTagName("script")[0],a;h.className+=" wf-loading";tk.src='https://use.typekit.net/'+config.kitId+'.js';tk.async=true;tk.onload=tk.onreadystatechange=function(){a=this.readyState;if(f||a&&a!="complete"&&a!="loaded")return;f=true;clearTimeout(t);try{Typekit.load(config)}catch(e){}};s.parentNode.insertBefore(tk,s)
  })(document);
</script>

  </body>
</html>
